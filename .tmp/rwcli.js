
  const proxyquire = require("proxyquire")
  const fs = require('fs')
  const path = require('path')
  const files = {}
  const fileOverrides = {"file:///Users/rohithgilla/Desktop/Life/Web_Devolopment/redwood-todo-app/web/src/pages/AppPage/AppPage.tsx":"import { Link, routes } from '@redwoodjs/router'\nimport { MetaTags } from '@redwoodjs/web'\n\nconst AppPage = () => {\n  return (\n    <>\n      <MetaTags\n        title=\"App\"\n        // description=\"App description\"\n        /* you should un-comment description and add a unique description, 155 characters or less\n        You can look at this documentation for best practices : https://developers.google.com/search/docs/advanced/appearance/good-titles-snippets */\n      />\n      <h1>AppPage</h1>\n      <p>\n        Find me in <code>./web/src/pages/AppPage/AppPage.tsx</code>\n      </p>\n      <p>\n        My default route is named <code>app</code>, link to me with `\n        <Link to={routes.app()}>App</Link>`\n      </p>\n    </>\n  )\n}\n\nexport default AppPage\n","file:///Users/rohithgilla/Desktop/Life/Web_Devolopment/redwood-todo-app/api/src/graphql/urls.sdl.ts":"export const schema = gql`\n  type Url {\n    id: Int!\n    longUrl: String!\n    shortUrl: String!\n    slug: String!\n    views: Int!\n    createdAt: DateTime!\n  }\n\n  type Query {\n    urls: [Url!]!\n    url(id: Int!): Url\n    findBySlug(slug: String!): Url\n  }\n\n  input CreateUrlInput {\n    longUrl: String!\n    shortUrl: String!\n    slug: String!\n    views: Int!\n  }\n\n  input UpdateUrlInput {\n    longUrl: String\n    shortUrl: String\n    slug: String\n    views: Int\n  }\n\n  type Mutation {\n    createUrl(input: CreateUrlInput!): Url!\n    updateUrl(id: Int!, input: UpdateUrlInput!): Url!\n    deleteUrl(id: Int!): Url!\n  }\n`\n","file:///Users/rohithgilla/Desktop/Life/Web_Devolopment/redwood-todo-app/api/src/services/urls/urls.ts":"import type { Prisma } from '@prisma/client'\nimport type { BeforeResolverSpecType } from '@redwoodjs/api'\n\nimport { db } from 'src/lib/db'\nimport { requireAuth } from 'src/lib/auth'\n\n// Used when the environment variable REDWOOD_SECURE_SERVICES=1\nexport const beforeResolver = (rules: BeforeResolverSpecType) => {\n  rules.add(requireAuth)\n}\n\nexport const urls = () => {\n  return db.url.findMany()\n}\n\nexport const url = ({ id }: Prisma.UrlWhereUniqueInput) => {\n  return db.url.findUnique({\n    where: { id },\n  })\n}\n\nexport const findBySlug = ({ slug }: Prisma.UrlWhereUniqueInput) => {\n  return db.url.findUnique({ where: { slug } })\n}\n\ninterface CreateUrlArgs {\n  input: Prisma.UrlCreateInput\n}\n\nexport const createUrl = ({ input }: CreateUrlArgs) => {\n  return db.url.create({\n    data: input,\n  })\n}\n\ninterface UpdateUrlArgs extends Prisma.UrlWhereUniqueInput {\n  input: Prisma.UrlUpdateInput\n}\n\nexport const updateUrl = ({ id, input }: UpdateUrlArgs) => {\n  return db.url.update({\n    data: input,\n    where: { id },\n  })\n}\n\nexport const deleteUrl = ({ id }: Prisma.UrlWhereUniqueInput) => {\n  return db.url.delete({\n    where: { id },\n  })\n}\n","file:///Users/rohithgilla/Desktop/Life/Web_Devolopment/redwood-todo-app/node_modules/.prisma/client/index.d.ts":"\n/**\n * Client\n**/\n\nimport * as runtime from '@prisma/client/runtime';\ndeclare const prisma: unique symbol\nexport type PrismaPromise<A> = Promise<A> & {[prisma]: true}\ntype UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P\ntype UnwrapTuple<Tuple extends readonly unknown[]> = {\n  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>\n};\n\n\n/**\n * Model UserExample\n */\n\nexport type UserExample = {\n  id: number\n  email: string\n  name: string | null\n}\n\n/**\n * Model Url\n */\n\nexport type Url = {\n  id: number\n  longUrl: string\n  shortUrl: string\n  slug: string\n  views: number\n  createdAt: Date\n}\n\n\n/**\n * ##  Prisma Client ʲˢ\n * \n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more UserExamples\n * const userExamples = await prisma.userExample.findMany()\n * ```\n *\n * \n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,\n  GlobalReject = 'rejectOnNotFound' extends keyof T\n    ? T['rejectOnNotFound']\n    : false\n      > {\n      /**\n       * @private\n       */\n      private fetcher;\n      /**\n       * @private\n       */\n      private readonly dmmf;\n      /**\n       * @private\n       */\n      private connectionPromise?;\n      /**\n       * @private\n       */\n      private disconnectionPromise?;\n      /**\n       * @private\n       */\n      private readonly engineConfig;\n      /**\n       * @private\n       */\n      private readonly measurePerformance;\n\n    /**\n   * ##  Prisma Client ʲˢ\n   * \n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more UserExamples\n   * const userExamples = await prisma.userExample.findMany()\n   * ```\n   *\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);\n  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): Promise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): Promise<any>;\n\n  /**\n   * Add a middleware\n   */\n  $use(cb: Prisma.Middleware): void\n\n  /**\n   * Executes a raw query and returns the number of affected rows\n   * @example\n   * ```\n   * // With parameters use prisma.$executeRaw``, values will be escaped automatically\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`\n   * // Or\n   * const result = await prisma.$executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)\n  * ```\n  * \n  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n  */\n  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;\n\n  /**\n   * Performs a raw query and returns the SELECT data\n   * @example\n   * ```\n   * // With parameters use prisma.$queryRaw``, values will be escaped automatically\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`\n   * // Or\n   * const result = await prisma.$queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')\n  * ```\n  * \n  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n  */\n  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>\n\n      /**\n   * `prisma.userExample`: Exposes CRUD operations for the **UserExample** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more UserExamples\n    * const userExamples = await prisma.userExample.findMany()\n    * ```\n    */\n  get userExample(): Prisma.UserExampleDelegate<GlobalReject>;\n\n  /**\n   * `prisma.url`: Exposes CRUD operations for the **Url** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Urls\n    * const urls = await prisma.url.findMany()\n    * ```\n    */\n  get url(): Prisma.UrlDelegate<GlobalReject>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  /**\n   * Prisma Client JS version: 2.29.1\n   * Query Engine version: 1be4cd60b89afa04b192acb1ef47758a39810f3a\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion \n\n  /**\n   * Utility Types\n   */\n\n  /**\n   * From https://github.com/sindresorhus/type-fest/\n   * Matches a JSON object.\n   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. \n   */\n  export type JsonObject = {[Key in string]?: JsonValue}\n \n  /**\n   * From https://github.com/sindresorhus/type-fest/\n   * Matches a JSON array.\n   */\n  export interface JsonArray extends Array<JsonValue> {}\n \n  /**\n   * From https://github.com/sindresorhus/type-fest/\n   * Matches any valid JSON value.\n   */\n  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray\n\n  /**\n   * Same as JsonObject, but allows undefined\n   */\n  export type InputJsonObject = {[Key in string]?: JsonValue}\n \n  export interface InputJsonArray extends Array<JsonValue> {}\n \n  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray\n   type SelectAndInclude = {\n    select: any\n    include: any\n  }\n  type HasSelect = {\n    select: any\n  }\n  type HasInclude = {\n    include: any\n  }\n  type CheckSelect<T, S, U> = T extends SelectAndInclude\n    ? 'Please either choose `select` or `include`'\n    : T extends HasSelect\n    ? U\n    : T extends HasInclude\n    ? U\n    : S\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = {\n    [key in keyof T]: T[key] extends false | undefined | null ? never : key\n  }[keyof T]\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Buffer\n  ? False\n  : T extends BigInt\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Exact<A, W = unknown> = \n  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<\n  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},\n  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>\n  : never;\n\n  type Narrowable = string | number | boolean | bigint;\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n  export function validator<V>(): <S>(select: Exact<S, V>) => S;\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but with an array\n   */\n  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n  class PrismaClientFetcher {\n    private readonly prisma;\n    private readonly debug;\n    private readonly hooks?;\n    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);\n    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;\n    sanitizeMessage(message: string): string;\n    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;\n  }\n\n  export const ModelName: {\n    UserExample: 'UserExample',\n    Url: 'Url'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  export type RejectOnNotFound = boolean | ((error: Error) => Error)\n  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }\n  export type RejectPerOperation =  { [P in \"findUnique\" | \"findFirst\"]?: RejectPerModel | RejectOnNotFound } \n  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False\n  export type HasReject<\n    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],\n    LocalRejectSettings,\n    Action extends PrismaAction,\n    Model extends ModelName\n  > = LocalRejectSettings extends RejectOnNotFound\n    ? IsReject<LocalRejectSettings>\n    : GlobalRejectSettings extends RejectPerOperation\n    ? Action extends keyof GlobalRejectSettings\n      ? GlobalRejectSettings[Action] extends boolean\n        ? IsReject<GlobalRejectSettings[Action]>\n        : GlobalRejectSettings[Action] extends RejectPerModel\n        ? Model extends keyof GlobalRejectSettings[Action]\n          ? IsReject<GlobalRejectSettings[Action][Model]>\n          : False\n        : False\n      : False\n    : IsReject<GlobalRejectSettings>\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n\n  export interface PrismaClientOptions {\n    /**\n     * Configure findUnique/findFirst to throw an error if the query returns null. \n     *  * @example\n     * ```\n     * // Reject on both findUnique/findFirst\n     * rejectOnNotFound: true\n     * // Reject only on findFirst with a custom error\n     * rejectOnNotFound: { findFirst: (err) => new Error(\"Custom Error\")}\n     * // Reject on user.findUnique with a custom error\n     * rejectOnNotFound: { findUnique: {User: (err) => new Error(\"User not found\")}}\n     * ```\n     */\n    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation\n    /**\n     * Overwrites the datasource url from your prisma.schema file\n     */\n    datasources?: Datasources\n\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n\n    /**\n     * @example\n     * ```\n     * // Defaults to stdout\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events\n     * log: [\n     *  { emit: 'stdout', level: 'query' },\n     *  { emit: 'stdout', level: 'info' },\n     *  { emit: 'stdout', level: 'warn' }\n     *  { emit: 'stdout', level: 'error' }\n     * ]\n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: Array<LogLevel | LogDefinition>\n  }\n\n  export type Hooks = {\n    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never\n  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?\n    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>\n    : never\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findMany'\n    | 'findFirst'\n    | 'create'\n    | 'createMany'\n    | 'update'\n    | 'updateMany'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n\n  /**\n   * These options are being passed in to the middleware as \"params\"\n   */\n  export type MiddlewareParams = {\n    model?: ModelName\n    action: PrismaAction\n    args: any\n    dataPath: string[]\n    runInTransaction: boolean\n  }\n\n  /**\n   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n   */\n  export type Middleware<T = any> = (\n    params: MiddlewareParams,\n    next: (params: MiddlewareParams) => Promise<T>,\n  ) => Promise<T>\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; \n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model UserExample\n   */\n\n\n  export type AggregateUserExample = {\n    _count: UserExampleCountAggregateOutputType | null\n    count: UserExampleCountAggregateOutputType | null\n    _avg: UserExampleAvgAggregateOutputType | null\n    avg: UserExampleAvgAggregateOutputType | null\n    _sum: UserExampleSumAggregateOutputType | null\n    sum: UserExampleSumAggregateOutputType | null\n    _min: UserExampleMinAggregateOutputType | null\n    min: UserExampleMinAggregateOutputType | null\n    _max: UserExampleMaxAggregateOutputType | null\n    max: UserExampleMaxAggregateOutputType | null\n  }\n\n  export type UserExampleAvgAggregateOutputType = {\n    id: number | null\n  }\n\n  export type UserExampleSumAggregateOutputType = {\n    id: number | null\n  }\n\n  export type UserExampleMinAggregateOutputType = {\n    id: number | null\n    email: string | null\n    name: string | null\n  }\n\n  export type UserExampleMaxAggregateOutputType = {\n    id: number | null\n    email: string | null\n    name: string | null\n  }\n\n  export type UserExampleCountAggregateOutputType = {\n    id: number\n    email: number\n    name: number\n    _all: number\n  }\n\n\n  export type UserExampleAvgAggregateInputType = {\n    id?: true\n  }\n\n  export type UserExampleSumAggregateInputType = {\n    id?: true\n  }\n\n  export type UserExampleMinAggregateInputType = {\n    id?: true\n    email?: true\n    name?: true\n  }\n\n  export type UserExampleMaxAggregateInputType = {\n    id?: true\n    email?: true\n    name?: true\n  }\n\n  export type UserExampleCountAggregateInputType = {\n    id?: true\n    email?: true\n    name?: true\n    _all?: true\n  }\n\n  export type UserExampleAggregateArgs = {\n    /**\n     * Filter which UserExample to aggregate.\n     * \n    **/\n    where?: UserExampleWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of UserExamples to fetch.\n     * \n    **/\n    orderBy?: Enumerable<UserExampleOrderByInput>\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     * \n    **/\n    cursor?: UserExampleWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` UserExamples from the position of the cursor.\n     * \n    **/\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` UserExamples.\n     * \n    **/\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned UserExamples\n    **/\n    _count?: true | UserExampleCountAggregateInputType\n    /**\n     * @deprecated since 2.23.0 please use `_count`\n    **/\n    count?: true | UserExampleCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: UserExampleAvgAggregateInputType\n    /**\n     * @deprecated since 2.23.0 please use `_avg`\n    **/\n    avg?: UserExampleAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: UserExampleSumAggregateInputType\n    /**\n     * @deprecated since 2.23.0 please use `_sum`\n    **/\n    sum?: UserExampleSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: UserExampleMinAggregateInputType\n    /**\n     * @deprecated since 2.23.0 please use `_min`\n    **/\n    min?: UserExampleMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: UserExampleMaxAggregateInputType\n    /**\n     * @deprecated since 2.23.0 please use `_max`\n    **/\n    max?: UserExampleMaxAggregateInputType\n  }\n\n  export type GetUserExampleAggregateType<T extends UserExampleAggregateArgs> = {\n        [P in keyof T & keyof AggregateUserExample]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateUserExample[P]>\n      : GetScalarType<T[P], AggregateUserExample[P]>\n  }\n\n\n    \n    \n  export type UserExampleGroupByArgs = {\n    where?: UserExampleWhereInput\n    orderBy?: Enumerable<UserExampleOrderByInput>\n    by: Array<UserExampleScalarFieldEnum>\n    having?: UserExampleScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: UserExampleCountAggregateInputType | true\n    _avg?: UserExampleAvgAggregateInputType\n    _sum?: UserExampleSumAggregateInputType\n    _min?: UserExampleMinAggregateInputType\n    _max?: UserExampleMaxAggregateInputType\n  }\n\n\n  export type UserExampleGroupByOutputType = {\n    id: number\n    email: string\n    name: string | null\n    _count: UserExampleCountAggregateOutputType | null\n    _avg: UserExampleAvgAggregateOutputType | null\n    _sum: UserExampleSumAggregateOutputType | null\n    _min: UserExampleMinAggregateOutputType | null\n    _max: UserExampleMaxAggregateOutputType | null\n  }\n\n  type GetUserExampleGroupByPayload<T extends UserExampleGroupByArgs> = Promise<\n    Array<\n      PickArray<UserExampleGroupByOutputType, T['by']> & \n        {\n          [P in ((keyof T) & (keyof UserExampleGroupByOutputType))]: P extends '_count' \n            ? T[P] extends boolean \n              ? number \n              : GetScalarType<T[P], UserExampleGroupByOutputType[P]> \n            : GetScalarType<T[P], UserExampleGroupByOutputType[P]>\n        }\n      > \n    >\n\n\n  export type UserExampleSelect = {\n    id?: boolean\n    email?: boolean\n    name?: boolean\n  }\n\n  export type UserExampleGetPayload<\n    S extends boolean | null | undefined | UserExampleArgs,\n    U = keyof S\n      > = S extends true\n        ? UserExample\n    : S extends undefined\n    ? never\n    : S extends UserExampleArgs | UserExampleFindManyArgs\n    ?'include' extends U\n    ? UserExample \n    : 'select' extends U\n    ? {\n    [P in TrueKeys<S['select']>]: P extends keyof UserExample ?UserExample [P]\n  : \n     never\n  } \n    : UserExample\n  : UserExample\n\n\n  type UserExampleCountArgs = Merge<\n    Omit<UserExampleFindManyArgs, 'select' | 'include'> & {\n      select?: UserExampleCountAggregateInputType | true\n    }\n  >\n\n  export interface UserExampleDelegate<GlobalRejectSettings> {\n    /**\n     * Find zero or one UserExample that matches the filter.\n     * @param {UserExampleFindUniqueArgs} args - Arguments to find a UserExample\n     * @example\n     * // Get one UserExample\n     * const userExample = await prisma.userExample.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n    **/\n    findUnique<T extends UserExampleFindUniqueArgs,  LocalRejectSettings = T[\"rejectOnNotFound\"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(\n      args: SelectSubset<T, UserExampleFindUniqueArgs>\n    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserExample'> extends True ? CheckSelect<T, Prisma__UserExampleClient<UserExample>, Prisma__UserExampleClient<UserExampleGetPayload<T>>> : CheckSelect<T, Prisma__UserExampleClient<UserExample | null >, Prisma__UserExampleClient<UserExampleGetPayload<T> | null >>\n\n    /**\n     * Find the first UserExample that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserExampleFindFirstArgs} args - Arguments to find a UserExample\n     * @example\n     * // Get one UserExample\n     * const userExample = await prisma.userExample.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n    **/\n    findFirst<T extends UserExampleFindFirstArgs,  LocalRejectSettings = T[\"rejectOnNotFound\"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(\n      args?: SelectSubset<T, UserExampleFindFirstArgs>\n    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserExample'> extends True ? CheckSelect<T, Prisma__UserExampleClient<UserExample>, Prisma__UserExampleClient<UserExampleGetPayload<T>>> : CheckSelect<T, Prisma__UserExampleClient<UserExample | null >, Prisma__UserExampleClient<UserExampleGetPayload<T> | null >>\n\n    /**\n     * Find zero or more UserExamples that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserExampleFindManyArgs=} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all UserExamples\n     * const userExamples = await prisma.userExample.findMany()\n     * \n     * // Get first 10 UserExamples\n     * const userExamples = await prisma.userExample.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const userExampleWithIdOnly = await prisma.userExample.findMany({ select: { id: true } })\n     * \n    **/\n    findMany<T extends UserExampleFindManyArgs>(\n      args?: SelectSubset<T, UserExampleFindManyArgs>\n    ): CheckSelect<T, PrismaPromise<Array<UserExample>>, PrismaPromise<Array<UserExampleGetPayload<T>>>>\n\n    /**\n     * Create a UserExample.\n     * @param {UserExampleCreateArgs} args - Arguments to create a UserExample.\n     * @example\n     * // Create one UserExample\n     * const UserExample = await prisma.userExample.create({\n     *   data: {\n     *     // ... data to create a UserExample\n     *   }\n     * })\n     * \n    **/\n    create<T extends UserExampleCreateArgs>(\n      args: SelectSubset<T, UserExampleCreateArgs>\n    ): CheckSelect<T, Prisma__UserExampleClient<UserExample>, Prisma__UserExampleClient<UserExampleGetPayload<T>>>\n\n    /**\n     * Delete a UserExample.\n     * @param {UserExampleDeleteArgs} args - Arguments to delete one UserExample.\n     * @example\n     * // Delete one UserExample\n     * const UserExample = await prisma.userExample.delete({\n     *   where: {\n     *     // ... filter to delete one UserExample\n     *   }\n     * })\n     * \n    **/\n    delete<T extends UserExampleDeleteArgs>(\n      args: SelectSubset<T, UserExampleDeleteArgs>\n    ): CheckSelect<T, Prisma__UserExampleClient<UserExample>, Prisma__UserExampleClient<UserExampleGetPayload<T>>>\n\n    /**\n     * Update one UserExample.\n     * @param {UserExampleUpdateArgs} args - Arguments to update one UserExample.\n     * @example\n     * // Update one UserExample\n     * const userExample = await prisma.userExample.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n    **/\n    update<T extends UserExampleUpdateArgs>(\n      args: SelectSubset<T, UserExampleUpdateArgs>\n    ): CheckSelect<T, Prisma__UserExampleClient<UserExample>, Prisma__UserExampleClient<UserExampleGetPayload<T>>>\n\n    /**\n     * Delete zero or more UserExamples.\n     * @param {UserExampleDeleteManyArgs} args - Arguments to filter UserExamples to delete.\n     * @example\n     * // Delete a few UserExamples\n     * const { count } = await prisma.userExample.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n    **/\n    deleteMany<T extends UserExampleDeleteManyArgs>(\n      args?: SelectSubset<T, UserExampleDeleteManyArgs>\n    ): PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more UserExamples.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserExampleUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many UserExamples\n     * const userExample = await prisma.userExample.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n    **/\n    updateMany<T extends UserExampleUpdateManyArgs>(\n      args: SelectSubset<T, UserExampleUpdateManyArgs>\n    ): PrismaPromise<BatchPayload>\n\n    /**\n     * Create or update one UserExample.\n     * @param {UserExampleUpsertArgs} args - Arguments to update or create a UserExample.\n     * @example\n     * // Update or create a UserExample\n     * const userExample = await prisma.userExample.upsert({\n     *   create: {\n     *     // ... data to create a UserExample\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the UserExample we want to update\n     *   }\n     * })\n    **/\n    upsert<T extends UserExampleUpsertArgs>(\n      args: SelectSubset<T, UserExampleUpsertArgs>\n    ): CheckSelect<T, Prisma__UserExampleClient<UserExample>, Prisma__UserExampleClient<UserExampleGetPayload<T>>>\n\n    /**\n     * Count the number of UserExamples.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserExampleCountArgs} args - Arguments to filter UserExamples to count.\n     * @example\n     * // Count the number of UserExamples\n     * const count = await prisma.userExample.count({\n     *   where: {\n     *     // ... the filter for the UserExamples we want to count\n     *   }\n     * })\n    **/\n    count<T extends UserExampleCountArgs>(\n      args?: Subset<T, UserExampleCountArgs>,\n    ): PrismaPromise<\n      T extends _Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], UserExampleCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a UserExample.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserExampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends UserExampleAggregateArgs>(args: Subset<T, UserExampleAggregateArgs>): PrismaPromise<GetUserExampleAggregateType<T>>\n\n    /**\n     * Group by UserExample.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserExampleGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends UserExampleGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: UserExampleGroupByArgs['orderBy'] }\n        : { orderBy?: UserExampleGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends TupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, UserExampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserExampleGroupByPayload<T> : Promise<InputErrors>\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for UserExample.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in \n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export class Prisma__UserExampleClient<T> implements PrismaPromise<T> {\n    [prisma]: true;\n    private readonly _dmmf;\n    private readonly _fetcher;\n    private readonly _queryType;\n    private readonly _rootField;\n    private readonly _clientMethod;\n    private readonly _args;\n    private readonly _dataPath;\n    private readonly _errorFormat;\n    private readonly _measurePerformance?;\n    private _isList;\n    private _callsite;\n    private _requestPromise?;\n    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);\n    readonly [Symbol.toStringTag]: 'PrismaClientPromise';\n\n\n    private get _document();\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n  }\n\n  // Custom InputTypes\n\n  /**\n   * UserExample findUnique\n   */\n  export type UserExampleFindUniqueArgs = {\n    /**\n     * Select specific fields to fetch from the UserExample\n     * \n    **/\n    select?: UserExampleSelect | null\n    /**\n     * Throw an Error if a UserExample can't be found\n     * \n    **/\n    rejectOnNotFound?: RejectOnNotFound\n    /**\n     * Filter, which UserExample to fetch.\n     * \n    **/\n    where: UserExampleWhereUniqueInput\n  }\n\n\n  /**\n   * UserExample findFirst\n   */\n  export type UserExampleFindFirstArgs = {\n    /**\n     * Select specific fields to fetch from the UserExample\n     * \n    **/\n    select?: UserExampleSelect | null\n    /**\n     * Throw an Error if a UserExample can't be found\n     * \n    **/\n    rejectOnNotFound?: RejectOnNotFound\n    /**\n     * Filter, which UserExample to fetch.\n     * \n    **/\n    where?: UserExampleWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of UserExamples to fetch.\n     * \n    **/\n    orderBy?: Enumerable<UserExampleOrderByInput>\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for UserExamples.\n     * \n    **/\n    cursor?: UserExampleWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` UserExamples from the position of the cursor.\n     * \n    **/\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` UserExamples.\n     * \n    **/\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of UserExamples.\n     * \n    **/\n    distinct?: Enumerable<UserExampleScalarFieldEnum>\n  }\n\n\n  /**\n   * UserExample findMany\n   */\n  export type UserExampleFindManyArgs = {\n    /**\n     * Select specific fields to fetch from the UserExample\n     * \n    **/\n    select?: UserExampleSelect | null\n    /**\n     * Filter, which UserExamples to fetch.\n     * \n    **/\n    where?: UserExampleWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of UserExamples to fetch.\n     * \n    **/\n    orderBy?: Enumerable<UserExampleOrderByInput>\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing UserExamples.\n     * \n    **/\n    cursor?: UserExampleWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` UserExamples from the position of the cursor.\n     * \n    **/\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` UserExamples.\n     * \n    **/\n    skip?: number\n    distinct?: Enumerable<UserExampleScalarFieldEnum>\n  }\n\n\n  /**\n   * UserExample create\n   */\n  export type UserExampleCreateArgs = {\n    /**\n     * Select specific fields to fetch from the UserExample\n     * \n    **/\n    select?: UserExampleSelect | null\n    /**\n     * The data needed to create a UserExample.\n     * \n    **/\n    data: XOR<UserExampleCreateInput, UserExampleUncheckedCreateInput>\n  }\n\n\n  /**\n   * UserExample update\n   */\n  export type UserExampleUpdateArgs = {\n    /**\n     * Select specific fields to fetch from the UserExample\n     * \n    **/\n    select?: UserExampleSelect | null\n    /**\n     * The data needed to update a UserExample.\n     * \n    **/\n    data: XOR<UserExampleUpdateInput, UserExampleUncheckedUpdateInput>\n    /**\n     * Choose, which UserExample to update.\n     * \n    **/\n    where: UserExampleWhereUniqueInput\n  }\n\n\n  /**\n   * UserExample updateMany\n   */\n  export type UserExampleUpdateManyArgs = {\n    data: XOR<UserExampleUpdateManyMutationInput, UserExampleUncheckedUpdateManyInput>\n    where?: UserExampleWhereInput\n  }\n\n\n  /**\n   * UserExample upsert\n   */\n  export type UserExampleUpsertArgs = {\n    /**\n     * Select specific fields to fetch from the UserExample\n     * \n    **/\n    select?: UserExampleSelect | null\n    /**\n     * The filter to search for the UserExample to update in case it exists.\n     * \n    **/\n    where: UserExampleWhereUniqueInput\n    /**\n     * In case the UserExample found by the `where` argument doesn't exist, create a new UserExample with this data.\n     * \n    **/\n    create: XOR<UserExampleCreateInput, UserExampleUncheckedCreateInput>\n    /**\n     * In case the UserExample was found with the provided `where` argument, update it with this data.\n     * \n    **/\n    update: XOR<UserExampleUpdateInput, UserExampleUncheckedUpdateInput>\n  }\n\n\n  /**\n   * UserExample delete\n   */\n  export type UserExampleDeleteArgs = {\n    /**\n     * Select specific fields to fetch from the UserExample\n     * \n    **/\n    select?: UserExampleSelect | null\n    /**\n     * Filter which UserExample to delete.\n     * \n    **/\n    where: UserExampleWhereUniqueInput\n  }\n\n\n  /**\n   * UserExample deleteMany\n   */\n  export type UserExampleDeleteManyArgs = {\n    where?: UserExampleWhereInput\n  }\n\n\n  /**\n   * UserExample without action\n   */\n  export type UserExampleArgs = {\n    /**\n     * Select specific fields to fetch from the UserExample\n     * \n    **/\n    select?: UserExampleSelect | null\n  }\n\n\n\n  /**\n   * Model Url\n   */\n\n\n  export type AggregateUrl = {\n    _count: UrlCountAggregateOutputType | null\n    count: UrlCountAggregateOutputType | null\n    _avg: UrlAvgAggregateOutputType | null\n    avg: UrlAvgAggregateOutputType | null\n    _sum: UrlSumAggregateOutputType | null\n    sum: UrlSumAggregateOutputType | null\n    _min: UrlMinAggregateOutputType | null\n    min: UrlMinAggregateOutputType | null\n    _max: UrlMaxAggregateOutputType | null\n    max: UrlMaxAggregateOutputType | null\n  }\n\n  export type UrlAvgAggregateOutputType = {\n    id: number | null\n    views: number | null\n  }\n\n  export type UrlSumAggregateOutputType = {\n    id: number | null\n    views: number | null\n  }\n\n  export type UrlMinAggregateOutputType = {\n    id: number | null\n    longUrl: string | null\n    shortUrl: string | null\n    slug: string | null\n    views: number | null\n    createdAt: Date | null\n  }\n\n  export type UrlMaxAggregateOutputType = {\n    id: number | null\n    longUrl: string | null\n    shortUrl: string | null\n    slug: string | null\n    views: number | null\n    createdAt: Date | null\n  }\n\n  export type UrlCountAggregateOutputType = {\n    id: number\n    longUrl: number\n    shortUrl: number\n    slug: number\n    views: number\n    createdAt: number\n    _all: number\n  }\n\n\n  export type UrlAvgAggregateInputType = {\n    id?: true\n    views?: true\n  }\n\n  export type UrlSumAggregateInputType = {\n    id?: true\n    views?: true\n  }\n\n  export type UrlMinAggregateInputType = {\n    id?: true\n    longUrl?: true\n    shortUrl?: true\n    slug?: true\n    views?: true\n    createdAt?: true\n  }\n\n  export type UrlMaxAggregateInputType = {\n    id?: true\n    longUrl?: true\n    shortUrl?: true\n    slug?: true\n    views?: true\n    createdAt?: true\n  }\n\n  export type UrlCountAggregateInputType = {\n    id?: true\n    longUrl?: true\n    shortUrl?: true\n    slug?: true\n    views?: true\n    createdAt?: true\n    _all?: true\n  }\n\n  export type UrlAggregateArgs = {\n    /**\n     * Filter which Url to aggregate.\n     * \n    **/\n    where?: UrlWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Urls to fetch.\n     * \n    **/\n    orderBy?: Enumerable<UrlOrderByInput>\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     * \n    **/\n    cursor?: UrlWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` Urls from the position of the cursor.\n     * \n    **/\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Urls.\n     * \n    **/\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned Urls\n    **/\n    _count?: true | UrlCountAggregateInputType\n    /**\n     * @deprecated since 2.23.0 please use `_count`\n    **/\n    count?: true | UrlCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: UrlAvgAggregateInputType\n    /**\n     * @deprecated since 2.23.0 please use `_avg`\n    **/\n    avg?: UrlAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: UrlSumAggregateInputType\n    /**\n     * @deprecated since 2.23.0 please use `_sum`\n    **/\n    sum?: UrlSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: UrlMinAggregateInputType\n    /**\n     * @deprecated since 2.23.0 please use `_min`\n    **/\n    min?: UrlMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: UrlMaxAggregateInputType\n    /**\n     * @deprecated since 2.23.0 please use `_max`\n    **/\n    max?: UrlMaxAggregateInputType\n  }\n\n  export type GetUrlAggregateType<T extends UrlAggregateArgs> = {\n        [P in keyof T & keyof AggregateUrl]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateUrl[P]>\n      : GetScalarType<T[P], AggregateUrl[P]>\n  }\n\n\n    \n    \n  export type UrlGroupByArgs = {\n    where?: UrlWhereInput\n    orderBy?: Enumerable<UrlOrderByInput>\n    by: Array<UrlScalarFieldEnum>\n    having?: UrlScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: UrlCountAggregateInputType | true\n    _avg?: UrlAvgAggregateInputType\n    _sum?: UrlSumAggregateInputType\n    _min?: UrlMinAggregateInputType\n    _max?: UrlMaxAggregateInputType\n  }\n\n\n  export type UrlGroupByOutputType = {\n    id: number\n    longUrl: string\n    shortUrl: string\n    slug: string\n    views: number\n    createdAt: Date\n    _count: UrlCountAggregateOutputType | null\n    _avg: UrlAvgAggregateOutputType | null\n    _sum: UrlSumAggregateOutputType | null\n    _min: UrlMinAggregateOutputType | null\n    _max: UrlMaxAggregateOutputType | null\n  }\n\n  type GetUrlGroupByPayload<T extends UrlGroupByArgs> = Promise<\n    Array<\n      PickArray<UrlGroupByOutputType, T['by']> & \n        {\n          [P in ((keyof T) & (keyof UrlGroupByOutputType))]: P extends '_count' \n            ? T[P] extends boolean \n              ? number \n              : GetScalarType<T[P], UrlGroupByOutputType[P]> \n            : GetScalarType<T[P], UrlGroupByOutputType[P]>\n        }\n      > \n    >\n\n\n  export type UrlSelect = {\n    id?: boolean\n    longUrl?: boolean\n    shortUrl?: boolean\n    slug?: boolean\n    views?: boolean\n    createdAt?: boolean\n  }\n\n  export type UrlGetPayload<\n    S extends boolean | null | undefined | UrlArgs,\n    U = keyof S\n      > = S extends true\n        ? Url\n    : S extends undefined\n    ? never\n    : S extends UrlArgs | UrlFindManyArgs\n    ?'include' extends U\n    ? Url \n    : 'select' extends U\n    ? {\n    [P in TrueKeys<S['select']>]: P extends keyof Url ?Url [P]\n  : \n     never\n  } \n    : Url\n  : Url\n\n\n  type UrlCountArgs = Merge<\n    Omit<UrlFindManyArgs, 'select' | 'include'> & {\n      select?: UrlCountAggregateInputType | true\n    }\n  >\n\n  export interface UrlDelegate<GlobalRejectSettings> {\n    /**\n     * Find zero or one Url that matches the filter.\n     * @param {UrlFindUniqueArgs} args - Arguments to find a Url\n     * @example\n     * // Get one Url\n     * const url = await prisma.url.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n    **/\n    findUnique<T extends UrlFindUniqueArgs,  LocalRejectSettings = T[\"rejectOnNotFound\"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(\n      args: SelectSubset<T, UrlFindUniqueArgs>\n    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Url'> extends True ? CheckSelect<T, Prisma__UrlClient<Url>, Prisma__UrlClient<UrlGetPayload<T>>> : CheckSelect<T, Prisma__UrlClient<Url | null >, Prisma__UrlClient<UrlGetPayload<T> | null >>\n\n    /**\n     * Find the first Url that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UrlFindFirstArgs} args - Arguments to find a Url\n     * @example\n     * // Get one Url\n     * const url = await prisma.url.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n    **/\n    findFirst<T extends UrlFindFirstArgs,  LocalRejectSettings = T[\"rejectOnNotFound\"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(\n      args?: SelectSubset<T, UrlFindFirstArgs>\n    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Url'> extends True ? CheckSelect<T, Prisma__UrlClient<Url>, Prisma__UrlClient<UrlGetPayload<T>>> : CheckSelect<T, Prisma__UrlClient<Url | null >, Prisma__UrlClient<UrlGetPayload<T> | null >>\n\n    /**\n     * Find zero or more Urls that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UrlFindManyArgs=} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Urls\n     * const urls = await prisma.url.findMany()\n     * \n     * // Get first 10 Urls\n     * const urls = await prisma.url.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const urlWithIdOnly = await prisma.url.findMany({ select: { id: true } })\n     * \n    **/\n    findMany<T extends UrlFindManyArgs>(\n      args?: SelectSubset<T, UrlFindManyArgs>\n    ): CheckSelect<T, PrismaPromise<Array<Url>>, PrismaPromise<Array<UrlGetPayload<T>>>>\n\n    /**\n     * Create a Url.\n     * @param {UrlCreateArgs} args - Arguments to create a Url.\n     * @example\n     * // Create one Url\n     * const Url = await prisma.url.create({\n     *   data: {\n     *     // ... data to create a Url\n     *   }\n     * })\n     * \n    **/\n    create<T extends UrlCreateArgs>(\n      args: SelectSubset<T, UrlCreateArgs>\n    ): CheckSelect<T, Prisma__UrlClient<Url>, Prisma__UrlClient<UrlGetPayload<T>>>\n\n    /**\n     * Delete a Url.\n     * @param {UrlDeleteArgs} args - Arguments to delete one Url.\n     * @example\n     * // Delete one Url\n     * const Url = await prisma.url.delete({\n     *   where: {\n     *     // ... filter to delete one Url\n     *   }\n     * })\n     * \n    **/\n    delete<T extends UrlDeleteArgs>(\n      args: SelectSubset<T, UrlDeleteArgs>\n    ): CheckSelect<T, Prisma__UrlClient<Url>, Prisma__UrlClient<UrlGetPayload<T>>>\n\n    /**\n     * Update one Url.\n     * @param {UrlUpdateArgs} args - Arguments to update one Url.\n     * @example\n     * // Update one Url\n     * const url = await prisma.url.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n    **/\n    update<T extends UrlUpdateArgs>(\n      args: SelectSubset<T, UrlUpdateArgs>\n    ): CheckSelect<T, Prisma__UrlClient<Url>, Prisma__UrlClient<UrlGetPayload<T>>>\n\n    /**\n     * Delete zero or more Urls.\n     * @param {UrlDeleteManyArgs} args - Arguments to filter Urls to delete.\n     * @example\n     * // Delete a few Urls\n     * const { count } = await prisma.url.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n    **/\n    deleteMany<T extends UrlDeleteManyArgs>(\n      args?: SelectSubset<T, UrlDeleteManyArgs>\n    ): PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Urls.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UrlUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Urls\n     * const url = await prisma.url.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n    **/\n    updateMany<T extends UrlUpdateManyArgs>(\n      args: SelectSubset<T, UrlUpdateManyArgs>\n    ): PrismaPromise<BatchPayload>\n\n    /**\n     * Create or update one Url.\n     * @param {UrlUpsertArgs} args - Arguments to update or create a Url.\n     * @example\n     * // Update or create a Url\n     * const url = await prisma.url.upsert({\n     *   create: {\n     *     // ... data to create a Url\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Url we want to update\n     *   }\n     * })\n    **/\n    upsert<T extends UrlUpsertArgs>(\n      args: SelectSubset<T, UrlUpsertArgs>\n    ): CheckSelect<T, Prisma__UrlClient<Url>, Prisma__UrlClient<UrlGetPayload<T>>>\n\n    /**\n     * Count the number of Urls.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UrlCountArgs} args - Arguments to filter Urls to count.\n     * @example\n     * // Count the number of Urls\n     * const count = await prisma.url.count({\n     *   where: {\n     *     // ... the filter for the Urls we want to count\n     *   }\n     * })\n    **/\n    count<T extends UrlCountArgs>(\n      args?: Subset<T, UrlCountArgs>,\n    ): PrismaPromise<\n      T extends _Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], UrlCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Url.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UrlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends UrlAggregateArgs>(args: Subset<T, UrlAggregateArgs>): PrismaPromise<GetUrlAggregateType<T>>\n\n    /**\n     * Group by Url.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UrlGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends UrlGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: UrlGroupByArgs['orderBy'] }\n        : { orderBy?: UrlGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends TupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, UrlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUrlGroupByPayload<T> : Promise<InputErrors>\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for Url.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in \n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export class Prisma__UrlClient<T> implements PrismaPromise<T> {\n    [prisma]: true;\n    private readonly _dmmf;\n    private readonly _fetcher;\n    private readonly _queryType;\n    private readonly _rootField;\n    private readonly _clientMethod;\n    private readonly _args;\n    private readonly _dataPath;\n    private readonly _errorFormat;\n    private readonly _measurePerformance?;\n    private _isList;\n    private _callsite;\n    private _requestPromise?;\n    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);\n    readonly [Symbol.toStringTag]: 'PrismaClientPromise';\n\n\n    private get _document();\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): Promise<T>;\n  }\n\n  // Custom InputTypes\n\n  /**\n   * Url findUnique\n   */\n  export type UrlFindUniqueArgs = {\n    /**\n     * Select specific fields to fetch from the Url\n     * \n    **/\n    select?: UrlSelect | null\n    /**\n     * Throw an Error if a Url can't be found\n     * \n    **/\n    rejectOnNotFound?: RejectOnNotFound\n    /**\n     * Filter, which Url to fetch.\n     * \n    **/\n    where: UrlWhereUniqueInput\n  }\n\n\n  /**\n   * Url findFirst\n   */\n  export type UrlFindFirstArgs = {\n    /**\n     * Select specific fields to fetch from the Url\n     * \n    **/\n    select?: UrlSelect | null\n    /**\n     * Throw an Error if a Url can't be found\n     * \n    **/\n    rejectOnNotFound?: RejectOnNotFound\n    /**\n     * Filter, which Url to fetch.\n     * \n    **/\n    where?: UrlWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Urls to fetch.\n     * \n    **/\n    orderBy?: Enumerable<UrlOrderByInput>\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for Urls.\n     * \n    **/\n    cursor?: UrlWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` Urls from the position of the cursor.\n     * \n    **/\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Urls.\n     * \n    **/\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of Urls.\n     * \n    **/\n    distinct?: Enumerable<UrlScalarFieldEnum>\n  }\n\n\n  /**\n   * Url findMany\n   */\n  export type UrlFindManyArgs = {\n    /**\n     * Select specific fields to fetch from the Url\n     * \n    **/\n    select?: UrlSelect | null\n    /**\n     * Filter, which Urls to fetch.\n     * \n    **/\n    where?: UrlWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Urls to fetch.\n     * \n    **/\n    orderBy?: Enumerable<UrlOrderByInput>\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing Urls.\n     * \n    **/\n    cursor?: UrlWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `±n` Urls from the position of the cursor.\n     * \n    **/\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Urls.\n     * \n    **/\n    skip?: number\n    distinct?: Enumerable<UrlScalarFieldEnum>\n  }\n\n\n  /**\n   * Url create\n   */\n  export type UrlCreateArgs = {\n    /**\n     * Select specific fields to fetch from the Url\n     * \n    **/\n    select?: UrlSelect | null\n    /**\n     * The data needed to create a Url.\n     * \n    **/\n    data: XOR<UrlCreateInput, UrlUncheckedCreateInput>\n  }\n\n\n  /**\n   * Url update\n   */\n  export type UrlUpdateArgs = {\n    /**\n     * Select specific fields to fetch from the Url\n     * \n    **/\n    select?: UrlSelect | null\n    /**\n     * The data needed to update a Url.\n     * \n    **/\n    data: XOR<UrlUpdateInput, UrlUncheckedUpdateInput>\n    /**\n     * Choose, which Url to update.\n     * \n    **/\n    where: UrlWhereUniqueInput\n  }\n\n\n  /**\n   * Url updateMany\n   */\n  export type UrlUpdateManyArgs = {\n    data: XOR<UrlUpdateManyMutationInput, UrlUncheckedUpdateManyInput>\n    where?: UrlWhereInput\n  }\n\n\n  /**\n   * Url upsert\n   */\n  export type UrlUpsertArgs = {\n    /**\n     * Select specific fields to fetch from the Url\n     * \n    **/\n    select?: UrlSelect | null\n    /**\n     * The filter to search for the Url to update in case it exists.\n     * \n    **/\n    where: UrlWhereUniqueInput\n    /**\n     * In case the Url found by the `where` argument doesn't exist, create a new Url with this data.\n     * \n    **/\n    create: XOR<UrlCreateInput, UrlUncheckedCreateInput>\n    /**\n     * In case the Url was found with the provided `where` argument, update it with this data.\n     * \n    **/\n    update: XOR<UrlUpdateInput, UrlUncheckedUpdateInput>\n  }\n\n\n  /**\n   * Url delete\n   */\n  export type UrlDeleteArgs = {\n    /**\n     * Select specific fields to fetch from the Url\n     * \n    **/\n    select?: UrlSelect | null\n    /**\n     * Filter which Url to delete.\n     * \n    **/\n    where: UrlWhereUniqueInput\n  }\n\n\n  /**\n   * Url deleteMany\n   */\n  export type UrlDeleteManyArgs = {\n    where?: UrlWhereInput\n  }\n\n\n  /**\n   * Url without action\n   */\n  export type UrlArgs = {\n    /**\n     * Select specific fields to fetch from the Url\n     * \n    **/\n    select?: UrlSelect | null\n  }\n\n\n\n  /**\n   * Enums\n   */\n\n  // Based on\n  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\n\n  export const UserExampleScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    name: 'name'\n  };\n\n  export type UserExampleScalarFieldEnum = (typeof UserExampleScalarFieldEnum)[keyof typeof UserExampleScalarFieldEnum]\n\n\n  export const UrlScalarFieldEnum: {\n    id: 'id',\n    longUrl: 'longUrl',\n    shortUrl: 'shortUrl',\n    slug: 'slug',\n    views: 'views',\n    createdAt: 'createdAt'\n  };\n\n  export type UrlScalarFieldEnum = (typeof UrlScalarFieldEnum)[keyof typeof UrlScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  /**\n   * Deep Input Types\n   */\n\n\n  export type UserExampleWhereInput = {\n    AND?: Enumerable<UserExampleWhereInput>\n    OR?: Enumerable<UserExampleWhereInput>\n    NOT?: Enumerable<UserExampleWhereInput>\n    id?: IntFilter | number\n    email?: StringFilter | string\n    name?: StringNullableFilter | string | null\n  }\n\n  export type UserExampleOrderByInput = {\n    id?: SortOrder\n    email?: SortOrder\n    name?: SortOrder\n  }\n\n  export type UserExampleWhereUniqueInput = {\n    id?: number\n    email?: string\n  }\n\n  export type UserExampleScalarWhereWithAggregatesInput = {\n    AND?: Enumerable<UserExampleScalarWhereWithAggregatesInput>\n    OR?: Enumerable<UserExampleScalarWhereWithAggregatesInput>\n    NOT?: Enumerable<UserExampleScalarWhereWithAggregatesInput>\n    id?: IntWithAggregatesFilter | number\n    email?: StringWithAggregatesFilter | string\n    name?: StringNullableWithAggregatesFilter | string | null\n  }\n\n  export type UrlWhereInput = {\n    AND?: Enumerable<UrlWhereInput>\n    OR?: Enumerable<UrlWhereInput>\n    NOT?: Enumerable<UrlWhereInput>\n    id?: IntFilter | number\n    longUrl?: StringFilter | string\n    shortUrl?: StringFilter | string\n    slug?: StringFilter | string\n    views?: IntFilter | number\n    createdAt?: DateTimeFilter | Date | string\n  }\n\n  export type UrlOrderByInput = {\n    id?: SortOrder\n    longUrl?: SortOrder\n    shortUrl?: SortOrder\n    slug?: SortOrder\n    views?: SortOrder\n    createdAt?: SortOrder\n  }\n\n  export type UrlWhereUniqueInput = {\n    id?: number\n    slug?: string\n  }\n\n  export type UrlScalarWhereWithAggregatesInput = {\n    AND?: Enumerable<UrlScalarWhereWithAggregatesInput>\n    OR?: Enumerable<UrlScalarWhereWithAggregatesInput>\n    NOT?: Enumerable<UrlScalarWhereWithAggregatesInput>\n    id?: IntWithAggregatesFilter | number\n    longUrl?: StringWithAggregatesFilter | string\n    shortUrl?: StringWithAggregatesFilter | string\n    slug?: StringWithAggregatesFilter | string\n    views?: IntWithAggregatesFilter | number\n    createdAt?: DateTimeWithAggregatesFilter | Date | string\n  }\n\n  export type UserExampleCreateInput = {\n    email: string\n    name?: string | null\n  }\n\n  export type UserExampleUncheckedCreateInput = {\n    id?: number\n    email: string\n    name?: string | null\n  }\n\n  export type UserExampleUpdateInput = {\n    email?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type UserExampleUncheckedUpdateInput = {\n    id?: IntFieldUpdateOperationsInput | number\n    email?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type UserExampleUpdateManyMutationInput = {\n    email?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type UserExampleUncheckedUpdateManyInput = {\n    id?: IntFieldUpdateOperationsInput | number\n    email?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n  }\n\n  export type UrlCreateInput = {\n    longUrl: string\n    shortUrl: string\n    slug: string\n    views?: number\n    createdAt?: Date | string\n  }\n\n  export type UrlUncheckedCreateInput = {\n    id?: number\n    longUrl: string\n    shortUrl: string\n    slug: string\n    views?: number\n    createdAt?: Date | string\n  }\n\n  export type UrlUpdateInput = {\n    longUrl?: StringFieldUpdateOperationsInput | string\n    shortUrl?: StringFieldUpdateOperationsInput | string\n    slug?: StringFieldUpdateOperationsInput | string\n    views?: IntFieldUpdateOperationsInput | number\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type UrlUncheckedUpdateInput = {\n    id?: IntFieldUpdateOperationsInput | number\n    longUrl?: StringFieldUpdateOperationsInput | string\n    shortUrl?: StringFieldUpdateOperationsInput | string\n    slug?: StringFieldUpdateOperationsInput | string\n    views?: IntFieldUpdateOperationsInput | number\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type UrlUpdateManyMutationInput = {\n    longUrl?: StringFieldUpdateOperationsInput | string\n    shortUrl?: StringFieldUpdateOperationsInput | string\n    slug?: StringFieldUpdateOperationsInput | string\n    views?: IntFieldUpdateOperationsInput | number\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type UrlUncheckedUpdateManyInput = {\n    id?: IntFieldUpdateOperationsInput | number\n    longUrl?: StringFieldUpdateOperationsInput | string\n    shortUrl?: StringFieldUpdateOperationsInput | string\n    slug?: StringFieldUpdateOperationsInput | string\n    views?: IntFieldUpdateOperationsInput | number\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type IntFilter = {\n    equals?: number\n    in?: Enumerable<number>\n    notIn?: Enumerable<number>\n    lt?: number\n    lte?: number\n    gt?: number\n    gte?: number\n    not?: NestedIntFilter | number\n  }\n\n  export type StringFilter = {\n    equals?: string\n    in?: Enumerable<string>\n    notIn?: Enumerable<string>\n    lt?: string\n    lte?: string\n    gt?: string\n    gte?: string\n    contains?: string\n    startsWith?: string\n    endsWith?: string\n    not?: NestedStringFilter | string\n  }\n\n  export type StringNullableFilter = {\n    equals?: string | null\n    in?: Enumerable<string> | null\n    notIn?: Enumerable<string> | null\n    lt?: string\n    lte?: string\n    gt?: string\n    gte?: string\n    contains?: string\n    startsWith?: string\n    endsWith?: string\n    not?: NestedStringNullableFilter | string | null\n  }\n\n  export type IntWithAggregatesFilter = {\n    equals?: number\n    in?: Enumerable<number>\n    notIn?: Enumerable<number>\n    lt?: number\n    lte?: number\n    gt?: number\n    gte?: number\n    not?: NestedIntWithAggregatesFilter | number\n    _count?: NestedIntFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    count?: NestedIntFilter\n    _avg?: NestedFloatFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    avg?: NestedFloatFilter\n    _sum?: NestedIntFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    sum?: NestedIntFilter\n    _min?: NestedIntFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    min?: NestedIntFilter\n    _max?: NestedIntFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    max?: NestedIntFilter\n  }\n\n  export type StringWithAggregatesFilter = {\n    equals?: string\n    in?: Enumerable<string>\n    notIn?: Enumerable<string>\n    lt?: string\n    lte?: string\n    gt?: string\n    gte?: string\n    contains?: string\n    startsWith?: string\n    endsWith?: string\n    not?: NestedStringWithAggregatesFilter | string\n    _count?: NestedIntFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    count?: NestedIntFilter\n    _min?: NestedStringFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    min?: NestedStringFilter\n    _max?: NestedStringFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    max?: NestedStringFilter\n  }\n\n  export type StringNullableWithAggregatesFilter = {\n    equals?: string | null\n    in?: Enumerable<string> | null\n    notIn?: Enumerable<string> | null\n    lt?: string\n    lte?: string\n    gt?: string\n    gte?: string\n    contains?: string\n    startsWith?: string\n    endsWith?: string\n    not?: NestedStringNullableWithAggregatesFilter | string | null\n    _count?: NestedIntNullableFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    count?: NestedIntNullableFilter\n    _min?: NestedStringNullableFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    min?: NestedStringNullableFilter\n    _max?: NestedStringNullableFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    max?: NestedStringNullableFilter\n  }\n\n  export type DateTimeFilter = {\n    equals?: Date | string\n    in?: Enumerable<Date> | Enumerable<string>\n    notIn?: Enumerable<Date> | Enumerable<string>\n    lt?: Date | string\n    lte?: Date | string\n    gt?: Date | string\n    gte?: Date | string\n    not?: NestedDateTimeFilter | Date | string\n  }\n\n  export type DateTimeWithAggregatesFilter = {\n    equals?: Date | string\n    in?: Enumerable<Date> | Enumerable<string>\n    notIn?: Enumerable<Date> | Enumerable<string>\n    lt?: Date | string\n    lte?: Date | string\n    gt?: Date | string\n    gte?: Date | string\n    not?: NestedDateTimeWithAggregatesFilter | Date | string\n    _count?: NestedIntFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    count?: NestedIntFilter\n    _min?: NestedDateTimeFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    min?: NestedDateTimeFilter\n    _max?: NestedDateTimeFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    max?: NestedDateTimeFilter\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type NullableStringFieldUpdateOperationsInput = {\n    set?: string | null\n  }\n\n  export type IntFieldUpdateOperationsInput = {\n    set?: number\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type NestedIntFilter = {\n    equals?: number\n    in?: Enumerable<number>\n    notIn?: Enumerable<number>\n    lt?: number\n    lte?: number\n    gt?: number\n    gte?: number\n    not?: NestedIntFilter | number\n  }\n\n  export type NestedStringFilter = {\n    equals?: string\n    in?: Enumerable<string>\n    notIn?: Enumerable<string>\n    lt?: string\n    lte?: string\n    gt?: string\n    gte?: string\n    contains?: string\n    startsWith?: string\n    endsWith?: string\n    not?: NestedStringFilter | string\n  }\n\n  export type NestedStringNullableFilter = {\n    equals?: string | null\n    in?: Enumerable<string> | null\n    notIn?: Enumerable<string> | null\n    lt?: string\n    lte?: string\n    gt?: string\n    gte?: string\n    contains?: string\n    startsWith?: string\n    endsWith?: string\n    not?: NestedStringNullableFilter | string | null\n  }\n\n  export type NestedIntWithAggregatesFilter = {\n    equals?: number\n    in?: Enumerable<number>\n    notIn?: Enumerable<number>\n    lt?: number\n    lte?: number\n    gt?: number\n    gte?: number\n    not?: NestedIntWithAggregatesFilter | number\n    _count?: NestedIntFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    count?: NestedIntFilter\n    _avg?: NestedFloatFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    avg?: NestedFloatFilter\n    _sum?: NestedIntFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    sum?: NestedIntFilter\n    _min?: NestedIntFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    min?: NestedIntFilter\n    _max?: NestedIntFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    max?: NestedIntFilter\n  }\n\n  export type NestedFloatFilter = {\n    equals?: number\n    in?: Enumerable<number>\n    notIn?: Enumerable<number>\n    lt?: number\n    lte?: number\n    gt?: number\n    gte?: number\n    not?: NestedFloatFilter | number\n  }\n\n  export type NestedStringWithAggregatesFilter = {\n    equals?: string\n    in?: Enumerable<string>\n    notIn?: Enumerable<string>\n    lt?: string\n    lte?: string\n    gt?: string\n    gte?: string\n    contains?: string\n    startsWith?: string\n    endsWith?: string\n    not?: NestedStringWithAggregatesFilter | string\n    _count?: NestedIntFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    count?: NestedIntFilter\n    _min?: NestedStringFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    min?: NestedStringFilter\n    _max?: NestedStringFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    max?: NestedStringFilter\n  }\n\n  export type NestedStringNullableWithAggregatesFilter = {\n    equals?: string | null\n    in?: Enumerable<string> | null\n    notIn?: Enumerable<string> | null\n    lt?: string\n    lte?: string\n    gt?: string\n    gte?: string\n    contains?: string\n    startsWith?: string\n    endsWith?: string\n    not?: NestedStringNullableWithAggregatesFilter | string | null\n    _count?: NestedIntNullableFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    count?: NestedIntNullableFilter\n    _min?: NestedStringNullableFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    min?: NestedStringNullableFilter\n    _max?: NestedStringNullableFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    max?: NestedStringNullableFilter\n  }\n\n  export type NestedIntNullableFilter = {\n    equals?: number | null\n    in?: Enumerable<number> | null\n    notIn?: Enumerable<number> | null\n    lt?: number\n    lte?: number\n    gt?: number\n    gte?: number\n    not?: NestedIntNullableFilter | number | null\n  }\n\n  export type NestedDateTimeFilter = {\n    equals?: Date | string\n    in?: Enumerable<Date> | Enumerable<string>\n    notIn?: Enumerable<Date> | Enumerable<string>\n    lt?: Date | string\n    lte?: Date | string\n    gt?: Date | string\n    gte?: Date | string\n    not?: NestedDateTimeFilter | Date | string\n  }\n\n  export type NestedDateTimeWithAggregatesFilter = {\n    equals?: Date | string\n    in?: Enumerable<Date> | Enumerable<string>\n    notIn?: Enumerable<Date> | Enumerable<string>\n    lt?: Date | string\n    lte?: Date | string\n    gt?: Date | string\n    gte?: Date | string\n    not?: NestedDateTimeWithAggregatesFilter | Date | string\n    _count?: NestedIntFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    count?: NestedIntFilter\n    _min?: NestedDateTimeFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    min?: NestedDateTimeFilter\n    _max?: NestedDateTimeFilter\n    /**\n     * @deprecated since 2.23 because Aggregation keywords got unified to use underscore as prefix to prevent field clashes.\n     * \n    **/\n    max?: NestedDateTimeFilter\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.DMMF.Document;\n}"}
  const FILE_SCHEME = 'file://'

  function URL_file(f) {
    if (f.startsWith(FILE_SCHEME))
      f = f.substr(FILE_SCHEME.length)
    return new URL(FILE_SCHEME + path.normalize(f)).href
  }

  proxyquire('@redwoodjs/cli/dist', {
    fs: {
      mkdir() {},
      mkdirSync(...args) {},
      writeFile(a, b) {
        files[URL_file(a)] = b
      },
      writeFileSync(a, b) {
        files[URL_file(a)] = b
      },
      readFileSync(...args) {
        const f = URL_file(args[0])
        if (fileOverrides[f]) return fileOverrides[f]
        return fs.readFileSync.apply(fs, args)
      },
      '@global': true,
    },
  })

  process.on('exit', () => {
    console.log("---------===----===--------")
    console.log(JSON.stringify(files, null, 2))
  })
  